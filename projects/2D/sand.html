<!DOCTYPE html>

<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta charset="utf-8" />
        <title>Sand Physics Derp</title>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.0/jquery.min.js"></script>
    </head>
    <body>
        <div class="controls">
            <div class="row" style="margin: 0px; padding: 10px;">
                <div class="col-md-2" style="margin: auto;">
                    Brush<br />
                    <input id="brush" type="range" value="5" />
                </div>
            </div>
        </div>
        <canvas id="world" style="z-index: 0;"></canvas>
    </body>
</html>

<style>
    html, body {
        margin: 0px;
        height: 100%;
        overflow-y: hidden;
        background-color: #0d3b02;
    }

    .controls {
        height: 6%;
        width: 100%;
        background-color: #654321;
        z-index: 1;
        position: absolute;
    }
</style>


<script>
    $(document).ready(function () {
        var canvas = document.getElementById("world");
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        var ctx = canvas.getContext("2d");
        var gravity = 20;

        //Queue's used for handling the general sand objects
        var queue_update = [];
        var queue_static = [];
        var queue_remove_update = [];

        //State Data for the World
        var interval;
        var static_counter = 3;
        var t = [-2, -1, 0, 1, 2];
        var sprinkle = false;
        var current_mouse_x = 100, current_mouse_y = 100;

        //Collision State Data
        var collision_matrix = []
        var maxX = window.innerWidth + 1;
        var maxY = window.innerHeight + gravity;

        //Populate Matrix
        for (var i = 0; i < maxX; i++) {
            for (var k = 0; k < maxY; k++) {
                if (k == 0) {
                    collision_matrix[i] = [];
                }
                collision_matrix[i][k] = {s: false, b: false};
            }//End for
        }//End for

        var SpawnSand = function (x, y) {
            if (x < 0) return;
            if (y < 0) return;
            if (x > (window.innerWidth - 1)) return;
            if (y > (window.innerHeight - 1)) return;
            var s = new Sand();
            s.Create(x, y);
            queue_update.push(s);
        };

        //Overall Update Call
        var Update = function () {
            Reset();

            //Update
            var l = queue_update.length;
            while (l--) {
                if (!queue_update[l].Update()) {
                    queue_static.push(queue_update.splice(l, 1)[0]);
                }//End if
            }//End while

            //Draw
            l = queue_update.length;
            while (l--) { queue_update[l].Draw(); }
            l = queue_static.length;
            while (l--) { queue_static[l].Draw(); }

            //Make Sand
            if (sprinkle) {
                //Check collision matrix so no overlap occurs.
                if (!collision_matrix[current_mouse_x][current_mouse_y].b) {
                    for (var i = 0; i < $("#brush").val() ; i++) {
                        if (i == 0) {
                            SpawnSand(current_mouse_x, current_mouse_y);
                        } else if (i % 2 == 0) {
                            SpawnSand(current_mouse_x + ((i * -1)/2), current_mouse_y);
                        } else {
                            SpawnSand(current_mouse_x + (((i-1)/2)+1), current_mouse_y);
                        }
                    }//End for
                }//End if
            }//End if

            //Restart function
            requestAnimationFrame(Update);
        };

        var Reset = function () {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        };

        var Sand = function () {
            this.x = 0;
            this.y = 0;
            this.past_x = 0;
            this.past_y = 0;
            this.width = 1;
            this.height = 1;
            this.speed = gravity;
            this.touch_bottom = false;
            this.Create = function (x, y) {
                this.x = x;
                this.y = y;
                this.past_x = x;
                this.past_y = y;
                collision_matrix[x][y].b = true;
                collision_matrix[x][y].s = false;
            };//End Create()
            this.Draw = function () {
                ctx.beginPath();
                //ctx.arc(this.x, this.y, this.width, 0, 2 * Math.PI);
                ctx.fillStyle = "#dddddd";
                ctx.fillRect(this.x, this.y, this.width, this.height);
                //ctx.stroke();
                //ctx.fill();
            };//End Draw()
            this.DrawOther = function () {
                ctx.beginPath();
                //ctx.arc(this.x, this.y, this.width, 0, 2 * Math.PI);
                ctx.fillStyle = "#000000";
                ctx.fillRect(this.x, this.y, this.width, this.height);
            };

            //False will place Sand particle in static queue.
            //True will keep it in update queue.
            this.Update = function () {
                //Do all physics checks here

                this.DrawOther();

                this.y += this.speed;


                //Collision check for other sand directly underneath
                var delta = (this.y - this.past_y);
                if (delta > 0) {
                    for (var t_i = 1; t_i <= delta; t_i++) {
                        if (collision_matrix[this.x][this.past_y + t_i].b && collision_matrix[this.x][this.past_y + t_i].s) {
                            this.speed = 0;
                            collision_matrix[this.past_x][this.past_y].b = false;
                            collision_matrix[this.past_x][this.past_y].s = false;
                            collision_matrix[this.x][this.past_y + (t_i - 1)].b = true;
                            collision_matrix[this.x][this.past_y + (t_i - 1)].s = true;
                            this.y = this.past_y + (t_i - 1);
                            return false;
                        }//End if
                    }//End for
                }//End if

                //Check border condition or very bottom
                if (this.y + this.height > canvas.height) {
                    this.speed = 0;
                    collision_matrix[this.past_x][this.past_y].b = false;
                    collision_matrix[this.past_x][this.past_y].s = false;
                    collision_matrix[Math.floor(this.x)][canvas.height - 1].b = true;
                    collision_matrix[Math.floor(this.x)][canvas.height - 1].s = true;
                    this.y = canvas.height-1;
                    return false;
                } else {
                    this.speed = gravity;
                }

                //Update Collision Matrix since we're moving downward.
                if (Math.floor(this.x) != this.past_x || Math.floor(this.y) != this.past_y) {
                    collision_matrix[this.past_x][this.past_y].b = false;
                    collision_matrix[this.past_x][this.past_y].s = false;
                    collision_matrix[Math.floor(this.x)][Math.floor(this.y)].b = true;
                    collision_matrix[Math.floor(this.x)][Math.floor(this.y)].s = false;
                    this.past_x = Math.floor(this.x);
                    this.past_y = Math.floor(this.y);
                }//End if

                return true;
            };//End Update()
        };

        //Set up World
        $("#world").click(function (e) {
            sprinkle = !sprinkle;
        });

        //Update X/Y When mouse is being moved.
        $("#world").mousemove(function (e) {
            if (e.pageX < 0) return;
            if (e.pageY < 0) return;
            if (e.pageX > (window.innerWidth - 1)) return;
            if (e.pageY > (window.innerHeight - 1)) return;
            current_mouse_x = e.pageX;
            current_mouse_y = e.pageY;
        });

        Update();
    });
</script>